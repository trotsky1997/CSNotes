C语言伪代码
	除变量的引用型外,其他还是用C
struct node{
int a;
int b;
}

	
样例输入 : ojeio
样例输出 : error

数据结构,
数据
数据项,
数据元素


存储方法(OS,数据结构):
顺序栈:顺序表实现的栈.
int a[MAX];
int top = -1;

a[++top] =t;
t = a[top--];


数据的逻辑结构:
1.线性结构:
一对一 关系

2.非线性结构
网状(图)\树状,一对多关系

数据存储方式(物理结构):
1.顺序存储
一个挨一个,内存地址连续
2.链式存储
前驱->后继->,环环相扣,但是内存地址不一定连续

实现指向功能

静态二叉树
int tree[Max][3];
tree [0]:
tree [0][0] tree [0][1] tree [0][2]
     值|左子节点|右子节点

3.索引存储(OS)
用一个专门的索引表去存储数据元素的地址
<关键字:地址>
4.散列存储
用hash函数,比如用名字来算出内存地址



数据访问方式:

1.直接访问:散列或者顺序
用一定的方式直接算出下标(内存地址).
int a[10];
a[6];


*(&a + sizeof(int) * i)
等价于
a[i]

2.间接访问
有查表的过程或者遍历访问

算法复杂度分析
1.描述思想
2.代码实现
3.分析复杂度


**时间复杂度
T(n)=O(f(n))

f(n):频度,基本操作的执行次数


int haha(int a)
{
while(1)
{
a *= 2;
a *= 2;
a *= 2;
a *= 2;	
a *= 2;
}
	return a;
}

O对一个多项式
1.找出最高次项
2.去掉最高次项的系数
O(n^1000)
O(f(n))


乘法规则
循环嵌套的计算
9*n^2
O(n^2)

for(...){//执行3*n次
for(...)//执行3*n次
{
 func();
}
}


加法规则
循环并列的计算
int fun3(){
fun1(...);//O(n^3)
fun2();//O(n^2)
}


O(fun3) =  O(n^3)



1.找基本操作
2.确定问题规模


*时间复杂度比阶
O(1)(通用)<<O(logn)<<O(n)(一遍扫描)<<O(nlogn)(分治法\递归)<<O(n^2)(嵌套遍历循环)<<O(2^n)<<O(n^n)<<O(n!)

**空间复杂度

int func(int *a)//a的大小是n
{

int c,d,e;//要了常数个
.....
 return *a;//O(1),也叫原地工作

}


计数排序 空间复杂度O(1)
时间复杂度O(1)

a = [3,6,9,8,7]
n是a的元素数量

int b[MAX];//MAX是已经定义的一个常量,足够大
//b初始化全部为零
for(int i = 0;i < length(a) -1;i++)
//                 n

{
	b[a[i]] = 1;//b[3] = 1;

}

b
0 1 2 3 4 5 6 7 8 9 ...
0  0 0 1 0 0 1 1 1 1...
重新对b遍历,0不输出,是1的输出下标

3 6 7 8 9...


算法设计题目三段式 13~15 写了就有分
1.描述思想
2.代码实现
3.分析复杂度


内存地址题目 15~18
进行了....操作,以....语句为基本操作,该操作进行了...次,所以本算法时间复杂度为..,额外使用了...空间,和n有关(无关),空间复杂度为...




十年考了七年线性表,两年树的搜索遍历
默写会背
算法复杂度分析选择题

17 13~14



-------------------------------


typedef struct Node
{
 	int data;
 	struct Node *next;
}Node;

以变长数组为例申请并初始化内存空间.
int* p;
p = (int* )malloc(n * sizeof(int));
p就是n大小的数组.


申请一个新链表节点

Node *p;
p = (Node *)malloc(sizeof(Node));







